During the development of this Inventory Management System, I encountered several challenges and learning moments that helped me grow not only in Java and JavaFX but also in structuring real-world applications using files and databases.

One of the main challenges I faced was implementing a clean save/load system using both object serialization (saving to .dat files) and SQLite database persistence. Initially, the save-to-file functionality was working fine, but I wasnâ€™t sure how to structure the file selection dialog and handle exceptions gracefully. After experimenting and getting guidance, I implemented the Java FileChooser along with ObjectOutputStream and ObjectInputStream to serialize and deserialize lists of Part and Product objects. I made sure to give users feedback on successful save/load actions using styled alerts.

The most significant challenge came while implementing the database part, particularly how to handle inheritance in the database. In Java, we had Part as the superclass, with InHouse and Outsourced as subclasses. This isn't directly supported in relational databases like SQLite. After some thought, I solved this by adding a boolean isInHouse field in the Parts table, and then using either the machineId or companyName column depending on the subclass. This way, I could store both types of parts in the same table and reconstruct them using conditionals in Java. This structure worked well and kept the database schema simple and flexible.

Another challenge was that the UI was not updating after loading from the database, even though data was clearly saved correctly. After debugging and printing out data from the database, I realized I was replacing the ObservableList rather than updating the existing reference used by the UI. This led to empty tables even though data existed. The fix was to use setAll() on the internal lists in the Inventory class, which refreshed the UI and solved the problem.

Overall, this project gave me hands-on experience with file I/O, SQLite, JavaFX FXML integration, and MVC-style structure. I also enjoyed customizing the UI with better button layouts and adding emojis to make the interface more modern and user-friendly. I had a lot of fun building this and now feel more confident working with databases and Java desktop applications.